<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OPTCG Card List</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <style>
    .filters{
      margin: 1em;
      border-bottom: #ccc;
      display: flex;
      justify-content: flex-start;
      align-items: flex-start;
      flex-wrap: wrap;
      gap:1em;
      font-size: 16px;
    }
    select, input {
      max-width: 300px;
    }
    .card-container {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      flex-wrap: wrap;
    }
    .card {
      margin: 1em;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: center;
      align-items: center;

      width: 194px;
      height: 271px;
    }
    .card.maxed {
      /* Remove always-on grayscale, only apply on hover */
      filter: none;
      cursor: not-allowed !important;
      pointer-events: auto;
    }
    .card.maxed:hover {
      filter: grayscale(1) brightness(0.8);
    }
    .card-image {
      transition: all 0.15s ease-in-out;
    }
    .card-image:hover{
      transform: scale(1.7);
    }

    .card-content {
      flex: 1;
    }
    /* Deck manager styles */
    .deck-manager {
      display: flex;
      align-items: center;
      gap: 0.7em;
      flex-wrap: wrap;
      flex-direction: row;
    }
    header {
      position: sticky;
      position: -webkit-sticky;
      top: 0;
      z-index: 100;
      background: var(--pico-background-color, #fff);
    }
    .deck-manager-controls {
      display: flex;
      align-items: center;
      gap: 0.7em;
      flex-wrap: wrap;
      width: 100%;
    }
    .deck-miniatures {
      display: flex;
      align-items: flex-end;
      gap: 0.5em;
      margin-left: 0;
      margin-top: 0.3em;
      flex-wrap: wrap;
      width: 100%;
    }
    .deck-miniature {
      min-width: 100px;
      min-height: 140px;
      /* was 120x170 */
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
    }
    .deck-miniature img {
      width: 100px;
      height: 140px;
      /* was 120x170 */
      object-fit: cover;
      border: 1px solid #bbb;
      border-radius: 2px;
      background: #fff;
      margin-bottom: 2px;
      transition: box-shadow 0.15s;
    }
    .deck-miniature-count {
      font-size: 1.2em;
      color: #333;
      background: #f5f5f5;
      border-radius: 8px;
      padding: 0 7px;
      position: absolute;
      top: 0;
      right: 0;
      transform: translate(40%, -40%);
      border: 1px solid #ccc;
      min-width: 2.2em;
      text-align: center;
      z-index: 2;
    }
    .deck-miniature-controls {
      display: none;
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      gap: 0.3em;
      z-index: 3;
    }
    .deck-miniature:hover .deck-miniature-controls {
      display: flex;
    }
    .deck-miniature-controls button {
      font-size: 1.1em;
      padding: 0.1em 0.5em;
      border-radius: 4px;
      border: 1px solid #bbb;
      background: #fff;
      cursor: pointer;
      transition: background 0.15s;
    }
    .deck-miniature-controls button:hover {
      background: #e0e0e0;
    }
    .deck-manager select,
    .deck-manager input[type="text"],
    .deck-manager button {
      font-size: 1em;
      padding: 0.3em 0.8em;
      height: 2.2em;
      min-width: unset;
      box-sizing: border-box;
      vertical-align: middle;
      margin-bottom: 0;
    }
    .deck-manager select {
      min-width: 90px;
    }
    .deck-manager input[type="text"] {
      min-width: 110px;
    }
    .deck-counters {
      display: flex;
      align-items: center;
      gap: 1.2em;
      font-size: 1em;
      margin-left: 1.5em;
      margin-top: 0.2em;
      flex-wrap: wrap;
    }
    .deck-counters span {
      color: #333;
      background: #f5f5f5;
      border-radius: 6px;
      padding: 0.2em 0.7em;
      border: 1px solid #ddd;
      font-size: 0.98em;
    }
  </style>
</head>
<body>
  <header style="border-bottom: 1px solid #ccc; padding: 0.5em; margin-bottom: 1em; font-size: 15px;">
    <form class="deck-manager">
      <div class="deck-manager-controls">
        <div class="deck-select-group">
          <span>Deck:</span>
          <select name="deck-select">
            <option value="">(Select deck)</option>
          </select>
        </div>
        <label>
          Name:
          <input type="text" name="deck-name" placeholder="Deck name" />
        </label>
        <button type="button" name="save-deck">Save</button>
        <button type="button" name="load-deck">Load</button>
        <button type="button" name="delete-deck" style="color:#b00;">Delete</button>
        <div class="deck-counters"></div>
      </div>
      <div class="deck-miniatures"></div>
    </form>
  </header>
  <main>
    <h1>OPTCG Card List</h1>
    <div class="filters">
      <div class="colors">
        <label>Colors:</label>
        <label>
          <input type="checkbox" name="color" onchange="updateFilteredCards()" value="red">
          Red
        </label>
        <label>
          <input type="checkbox" name="color" onchange="updateFilteredCards()" value="green">
          Green
        </label>
        <label>
          <input type="checkbox" name="color" onchange="updateFilteredCards()" value="blue">
          Blue
        </label>
        <label>
          <input type="checkbox" name="color" onchange="updateFilteredCards()" value="purple">
          Purple
        </label>
        <label>
          <input type="checkbox" name="color" onchange="updateFilteredCards()" value="yellow">
          Yellow
        </label>
        <label>
          <input type="checkbox" name="color" onchange="updateFilteredCards()" value="black">
          Black
        </label>
        </div>
      <div class="category">
        <label>Category:</label>
        <label>
          <input type="checkbox" name="category" onchange="updateFilteredCards()" value="leader">
            Leader
        </label>
        <label>
          <input type="checkbox" name="category" onchange="updateFilteredCards()" value="character">
            Character
        </label>
        <label>
          <input type="checkbox" name="category" onchange="updateFilteredCards()" value="event">
            Event
        </label>
        <label>
          <input type="checkbox" name="category" onchange="updateFilteredCards()" value="stage">
            Stage
        </label>
      </div>
      <div class="counter">
        <label>Counter:</label>
        <label>
          <input type="checkbox" name="counter" onchange="updateFilteredCards()" value="0">
            None
        </label>
        <label>
          <input type="checkbox" name="counter" onchange="updateFilteredCards()" value="1000">
            1000
        </label>
        <label>
          <input type="checkbox" name="counter" onchange="updateFilteredCards()" value="2000">
            2000
        </label>
      </div>
      <div>
        <label>Effects:</label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="atk">
          When Attacking
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="don">
          DON!! x
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="oatk">
          On Your Opponent's Attack
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="opt">
          Once Per Turn
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="opl">
          On Play
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="rsh">
          Rush
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="blk">
          Blocker
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="onblk">
          On Block
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="main">
          Activate: Main
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="trg">
          Trigger
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="ctr">
          Counter
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="end">
          End of Your Turn
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="oko">
          On K.O.
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="trn">
          Your Turn
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="bsh">
          Banish
        </label>
        <label>
          <input type="checkbox" name="tag" onchange="updateFilteredCards()" value="dbl">
          Double Attack
        </label>
      </div>
      <div class="search">
        <label>Text Search (seperated by commas):</label>
        <input type="text" placeholder="strawhat" onchange="updateFilteredCards()" />
      </div>
      <div class="alternate">
        <label>Alternate arts (Parallel):</label>
        <label>
          <input type="checkbox" name="hide_alternate_art" onchange="updateFilteredCards()" value="true">
            Hide
        </label>
      </div>
      <div class="sort">
        <label>Sort:</label>
        <select onchange="updateFilteredCards()">
          <option value="code">Code</option>
          <option value="costASC">Cost ‚¨Ü</option>
          <option value="costDESC">Cost ‚¨á</option>
        </select>
      </div>
    </div>
    <div class="card-container"></div>
  </main>

  <script>
    const cardContainer = document.querySelector('.card-container');
    const allCards = [];
    var filteredCards = [];
    let currentDeck = [];
    const deckMiniatures = document.querySelector('.deck-miniatures');
    const deckSelect = document.querySelector('select[name="deck-select"]');
    const deckNameInput = document.querySelector('input[name="deck-name"]');
    const saveDeckBtn = document.querySelector('button[name="save-deck"]');
    const loadDeckBtn = document.querySelector('button[name="load-deck"]');
    const deleteDeckBtn = document.querySelector('button[name="delete-deck"]');
    const deckCounters = document.querySelector('.deck-counters');

    function renderDeckCounters() {
      // Count total and by type
      const typeCounts = {};
      let total = 0;
      let count1000 = 0;
      let count2000 = 0;
      currentDeck.forEach(card => {
        const type = (card.category || 'Unknown').toLowerCase();
        typeCounts[type] = (typeCounts[type] || 0) + 1;
        total++;
        if (card.counter == 1000) count1000++;
        if (card.counter == 2000) count2000++;
      });
      let html = `<span><b>Total:</b> ${total}</span>`;
      for (const [type, count] of Object.entries(typeCounts)) {
        html += `<span><b>${type.charAt(0).toUpperCase() + type.slice(1)}:</b> ${count}</span>`;
      }
      html += `<span><b>1000 Counters:</b> ${count1000}</span>`;
      html += `<span><b>2000 Counters:</b> ${count2000}</span>`;
      deckCounters.innerHTML = html;
    }

    function renderDeckMiniatures() {
      deckMiniatures.innerHTML = '';
      // Count unique cards by code only
      const cardCount = {};
      currentDeck.forEach(card => {
        const key = card.code;
        if (!cardCount[key]) cardCount[key] = { card, count: 0 };
        cardCount[key].count++;
      });
      Object.values(cardCount).forEach(({ card, count }) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'deck-miniature';
        const img = document.createElement('img');
        img.src = card.backup_image;
        img.alt = card.name;
        img.title = card.name;
        wrapper.appendChild(img);
        const countSpan = document.createElement('span');
        countSpan.className = 'deck-miniature-count';
        countSpan.textContent = count;
        wrapper.appendChild(countSpan);
        // Controls for +, -, and clear
        const controls = document.createElement('div');
        controls.className = 'deck-miniature-controls';
        // Decrement button
        const btnMinus = document.createElement('button');
        btnMinus.type = 'button';
        btnMinus.innerHTML = '‚àí';
        btnMinus.title = 'Remove one';
        btnMinus.style.color = '#b00';
        btnMinus.onclick = (e) => {
          e.stopPropagation();
          const idx = currentDeck.findIndex(c => c.code === card.code);
          if (idx !== -1) {
            currentDeck.splice(idx, 1);
            renderDeckMiniatures();
            renderDeckCounters();
          }
        };
        // Increment button
        const btnPlus = document.createElement('button');
        btnPlus.type = 'button';
        btnPlus.innerHTML = '+';
        btnPlus.title = 'Add one';
        btnPlus.style.color = '#080';
        btnPlus.onclick = (e) => {
          e.stopPropagation();
          const currentCount = currentDeck.filter(c => c.code === card.code).length;
          // If leader, only allow 1
          if (card.category && card.category.toLowerCase() === 'leader') {
            if (currentCount >= 1) {
              alert('You can only have 1 Leader card in your deck.');
              return;
            }
          } else if (currentCount >= 4) {
            alert('You can only have up to 4 copies of a card in your deck.');
            return;
          }
          if (currentDeck.length >= 51) {
            showToast('Deck is full (51 cards).');
            return;
          }
          const cardObj = allCards.find(c => c.code === card.code);
          if (cardObj) {
            currentDeck.push(cardObj);
            renderDeckMiniatures();
            renderDeckCounters();
          }
        };
        // Clear button
        const btnClear = document.createElement('button');
        btnClear.type = 'button';
        btnClear.innerHTML = '<span style="font-size:1.1em;color:#555;">üóëÔ∏è</span>';
        btnClear.title = 'Remove all';
        btnClear.onclick = (e) => {
          e.stopPropagation();
          currentDeck = currentDeck.filter(c => c.code !== card.code);
          renderDeckMiniatures();
          renderDeckCounters();
        };
        controls.appendChild(btnMinus);
        controls.appendChild(btnPlus);
        controls.appendChild(btnClear);
        wrapper.appendChild(controls);
        deckMiniatures.appendChild(wrapper);
      });
      renderDeckCounters();
      updateSaveButtonState();
    }

    function showToast(message) {
      let toast = document.createElement('div');
      toast.textContent = message;
      toast.style.position = 'fixed';
      toast.style.top = '1.2em';
      toast.style.right = '1.5em';
      toast.style.left = '';
      toast.style.transform = '';
      toast.style.background = 'rgba(40,40,40,0.95)';
      toast.style.color = '#fff';
      toast.style.padding = '0.7em 1.5em';
      toast.style.borderRadius = '8px';
      toast.style.fontSize = '1.1em';
      toast.style.zIndex = 9999;
      toast.style.boxShadow = '0 2px 8px rgba(0,0,0,0.18)';
      document.body.appendChild(toast);
      setTimeout(() => {
        toast.style.transition = 'opacity 0.4s';
        toast.style.opacity = 0;
        setTimeout(() => toast.remove(), 400);
      }, 1200);
    }

    function saveDeckToLocalStorage() {
      const name = deckNameInput.value.trim();
      if (!name) {
        alert('Please enter a deck name.');
        return;
      }
      if (currentDeck.length !== 51) {
        showToast('Deck must have exactly 51 cards to save.');
        return;
      }
      const decks = JSON.parse(localStorage.getItem('op_decks') || '{}');
      decks[name] = currentDeck.map(card => card.code + '|' + card.art_variant);
      localStorage.setItem('op_decks', JSON.stringify(decks));
      updateDeckDropdown();
      showToast('Deck saved!');
      updateSaveButtonState();
    }

    function updateDeckDropdown() {
      const decks = JSON.parse(localStorage.getItem('op_decks') || '{}');
      deckSelect.innerHTML = '<option value="">(Select deck)</option>';
      Object.keys(decks).forEach(deckName => {
        const opt = document.createElement('option');
        opt.value = deckName;
        opt.textContent = deckName;
        deckSelect.appendChild(opt);
      });
    }

    function loadDeckFromLocalStorage() {
      const selected = deckSelect.value;
      if (!selected) return;
      const decks = JSON.parse(localStorage.getItem('op_decks') || '{}');
      const deckArr = decks[selected] || [];
      currentDeck = deckArr.map(key => {
        const [code, art_variant] = key.split('|');
        return allCards.find(card => card.code === code && String(card.art_variant) === art_variant);
      }).filter(Boolean);
      deckNameInput.value = selected;
      deckSelect.value = selected;
      renderDeckMiniatures();
      renderDeckCounters();
      showToast('Deck loaded!');
      updateSaveButtonState();
    }

    function deleteSelectedDeck() {
      const selected = deckSelect.value;
      if (!selected) {
        showToast('No deck selected.');
        return;
      }
      if (!confirm(`Delete deck '${selected}'? This cannot be undone.`)) return;
      const decks = JSON.parse(localStorage.getItem('op_decks') || '{}');
      delete decks[selected];
      localStorage.setItem('op_decks', JSON.stringify(decks));
      updateDeckDropdown();
      deckSelect.value = '';
      deckNameInput.value = '';
      currentDeck = [];
      renderDeckMiniatures();
      renderDeckCounters();
      showToast('Deck deleted!');
      updateSaveButtonState();
    }

    deckNameInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveDeckToLocalStorage();
      }
    });

    function addCardToDeck(card) {
      // Limit to 4 of each unique card code, or 1 for leader
      const count = currentDeck.filter(c => c.code === card.code).length;
      if (card.category && card.category.toLowerCase() === 'leader') {
        if (count >= 1) {
          return;
        }
        // Only allow one leader in the deck at all
        if (currentDeck.some(c => c.category && c.category.toLowerCase() === 'leader')) {
          return;
        }
      } else if (count >= 4) {
        return;
      }
      if (currentDeck.length >= 51) {
        showToast('Deck is full (51 cards).');
        return;
      }
      currentDeck.push(card);
      renderDeckMiniatures();
      renderDeckCounters();
    }

    function setupCardClickHandlers() {
      document.querySelectorAll('.card').forEach((cardDiv, idx) => {
        // Always recalculate count/maxCount on each event for up-to-date state
        const cardData = filteredCards[idx];
        const isLeader = cardData.category && cardData.category.toLowerCase() === 'leader';
        cardDiv.onmouseenter = cardDiv.onmousemove = function() {
          const count = currentDeck.filter(c => c.code === cardData.code).length;
          const maxCount = isLeader ? 1 : 4;
          // Also gray out if deck is full
          if (count >= maxCount || currentDeck.length >= 51) {
            cardDiv.classList.add('maxed');
            cardDiv.style.cursor = 'not-allowed';
          } else {
            cardDiv.classList.remove('maxed');
            cardDiv.style.cursor = 'pointer';
          }
        };
        cardDiv.onmouseleave = function() {
          cardDiv.classList.remove('maxed');
          cardDiv.style.cursor = 'pointer';
        };
        // Left click: add one if not maxed and deck not full
        cardDiv.onclick = (e) => {
          const count = currentDeck.filter(c => c.code === cardData.code).length;
          const maxCount = isLeader ? 1 : 4;
          if (count >= maxCount || currentDeck.length >= 51) return;
          addCardToDeck(cardData);
        };
        // Right click: add as many as possible up to max, but not over 51, prevent context menu
        cardDiv.oncontextmenu = (e) => {
          e.preventDefault();
          const count = currentDeck.filter(c => c.code === cardData.code).length;
          const maxCount = isLeader ? 1 : 4;
          if (count >= maxCount || currentDeck.length >= 51) return;
          const toAdd = Math.min(maxCount - count, 51 - currentDeck.length);
          for (let i = 0; i < toAdd; i++) {
            addCardToDeck(cardData);
          }
        };
      });
    }

    function updateFilteredCards(){

      const tag_map = {
        atk: "When Attacking",
        don: "DON!! x",
        oatk: "On Your Opponent's Attack",
        opt: "Once Per Turn",
        opl: "On Play",
        rsh: "Rush",
        blk: "Blocker",
        onblk: "On Block",
        main: "Activate: Main",
        trg: "Trigger",
        ctr: "Counter",
        end: "End of Your Turn",
        oko: "On K.O.",
        trn: "Your Turn",
        bsh: "Banish",
        dbl: "Double Attack"
      }

      const searchFilter = document.querySelector(".search input[type='text']").value;
      const colorFilter = Array.from(document.querySelectorAll("input[name='color']")).map(({value, checked})=>checked && value).filter(value =>!!value);
      const categoryFilter = Array.from(document.querySelectorAll("input[name='category']")).map(({value, checked})=>checked && value).filter(value =>!!value);
      const counterFilter = Array.from(document.querySelectorAll("input[name='counter']")).map(({value, checked})=>checked && value).filter(value =>!!value);
      const alternateArtFilter = Array.from(document.querySelectorAll("input[name='hide_alternate_art']")).map(({value, checked})=>checked && value).filter(value =>!!value);
      const sortCriteria = document.querySelector(".sort select").value;
      const tagCriteria = Array.from(document.querySelectorAll("input[name='tag']")).map(({value, checked})=>checked && value).filter(value =>!!value);
      filteredCards = allCards;


      if(searchFilter) {
        // Support comma-separated AND search for multiple terms
        const terms = searchFilter.split(',').map(t => t.trim().toLowerCase()).filter(Boolean);
        filteredCards = filteredCards.filter(({name, type, effect, trigger, code}) => {
          const searchableFields = [name, type, effect, trigger, code].map(f => (f || '').toLowerCase());
          // All terms must be found in any field
          return terms.every(term => searchableFields.some(field => field.includes(term)));
        });
      }
      if(colorFilter.length>0)
        filteredCards = filteredCards.filter(({color}) =>
          colorFilter.includes(color.toLowerCase())
        )
      if(categoryFilter.length>0)
      filteredCards = filteredCards.filter(({category}) =>
        categoryFilter.includes(category.toLowerCase())
      )
      if(counterFilter.length>0)
      filteredCards = filteredCards.filter(({counter}) =>
        counterFilter.includes(counter.toString())
      )
      if(alternateArtFilter.length>0)
      filteredCards = filteredCards.filter(({art_variant})=> art_variant === 0)
      if(tagCriteria.length>0)
      filteredCards = filteredCards.filter(({tags}) => {
          if(!tags)
            return false;
          const tagSet = new Set(tags.split(','));
          return tagCriteria.every(element => tagSet.has(element));
      });
      console.log({filteredCards});

      filteredCards.sort((a, b)=> {
          if(sortCriteria === 'code')
            return a.code.localeCompare(b.code);
          else if(sortCriteria === 'costASC')
            return a.cost - b.cost;
          else if (sortCriteria === 'costDESC')
            return b.cost - a.cost;
      })
      
      displayFilteredCards();
    }

    function imageErrorHandler(element) {
      console.log(element);
      element.onerror = null;
      element.parentNode.children[0].srcset = element.parentNode.children[1].srcset = element.src;
    }

    function displayFilteredCards(){
      cardContainer.innerHTML = "";
      filteredCards.forEach(item => {
          const card = document.createElement('div');
          card.classList.add('card');

          const image = document.createElement('picture');
          image.classList.add('card-image');

          preferredSource = document.createElement('source');
          preferredSource.setAttribute('srcset', item.image);
          backupSource = document.createElement('source');
          backupSource.setAttribute('srcset', item.backup_image);

          fallbackImage = document.createElement('img');
          fallbackImage.src = item.backup_image;
          fallbackImage.loading="lazy";
          fallbackImage.onerror = function() {
            this.onerror = null;
            this.parentNode.children[0].srcset = this.parentNode.children[1].srcset = this.src;
            return true;
          };

          image.appendChild(preferredSource);
          image.appendChild(backupSource);
          image.appendChild(fallbackImage);
          card.appendChild(image);

          cardContainer.appendChild(card);
        });
      setupCardClickHandlers();
    }

    function isDeckEqual(deckA, deckB) {
      if (!Array.isArray(deckA) || !Array.isArray(deckB)) return false;
      if (deckA.length !== deckB.length) return false;
      // Compare sorted arrays of card keys
      const aSorted = [...deckA].sort();
      const bSorted = [...deckB].sort();
      for (let i = 0; i < aSorted.length; i++) {
        if (aSorted[i] !== bSorted[i]) return false;
      }
      return true;
    }

    function updateSaveButtonState() {
      const name = deckNameInput.value.trim();
      const decks = JSON.parse(localStorage.getItem('op_decks') || '{}');
      const savedDeck = decks[name] || [];
      const currentDeckKeys = currentDeck.map(card => card.code + '|' + card.art_variant);
      // Disable if deck is empty, not exactly 51 cards, or no changes from saved
      if (currentDeck.length !== 51 || (savedDeck.length > 0 && isDeckEqual(savedDeck, currentDeckKeys))) {
        saveDeckBtn.disabled = true;
      } else {
        saveDeckBtn.disabled = false;
      }
    }

    // Call updateSaveButtonState on relevant events
    ['input', 'change'].forEach(evt => {
      deckNameInput.addEventListener(evt, updateSaveButtonState);
      deckSelect.addEventListener(evt, updateSaveButtonState);
    });

    // Also call after deck changes
    function renderDeckMiniatures() {
      deckMiniatures.innerHTML = '';
      // Count unique cards by code only
      const cardCount = {};
      currentDeck.forEach(card => {
        const key = card.code;
        if (!cardCount[key]) cardCount[key] = { card, count: 0 };
        cardCount[key].count++;
      });
      Object.values(cardCount).forEach(({ card, count }) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'deck-miniature';
        const img = document.createElement('img');
        img.src = card.backup_image;
        img.alt = card.name;
        img.title = card.name;
        wrapper.appendChild(img);
        const countSpan = document.createElement('span');
        countSpan.className = 'deck-miniature-count';
        countSpan.textContent = count;
        wrapper.appendChild(countSpan);
        // Controls for +, -, and clear
        const controls = document.createElement('div');
        controls.className = 'deck-miniature-controls';
        // Decrement button
        const btnMinus = document.createElement('button');
        btnMinus.type = 'button';
        btnMinus.innerHTML = '‚àí';
        btnMinus.title = 'Remove one';
        btnMinus.style.color = '#b00';
        btnMinus.onclick = (e) => {
          e.stopPropagation();
          const idx = currentDeck.findIndex(c => c.code === card.code);
          if (idx !== -1) {
            currentDeck.splice(idx, 1);
            renderDeckMiniatures();
            renderDeckCounters();
          }
        };
        // Increment button
        const btnPlus = document.createElement('button');
        btnPlus.type = 'button';
        btnPlus.innerHTML = '+';
        btnPlus.title = 'Add one';
        btnPlus.style.color = '#080';
        btnPlus.onclick = (e) => {
          e.stopPropagation();
          const currentCount = currentDeck.filter(c => c.code === card.code).length;
          // If leader, only allow 1
          if (card.category && card.category.toLowerCase() === 'leader') {
            if (currentCount >= 1) {
              alert('You can only have 1 Leader card in your deck.');
              return;
            }
          } else if (currentCount >= 4) {
            alert('You can only have up to 4 copies of a card in your deck.');
            return;
          }
          if (currentDeck.length >= 51) {
            showToast('Deck is full (51 cards).');
            return;
          }
          const cardObj = allCards.find(c => c.code === card.code);
          if (cardObj) {
            currentDeck.push(cardObj);
            renderDeckMiniatures();
            renderDeckCounters();
          }
        };
        // Clear button
        const btnClear = document.createElement('button');
        btnClear.type = 'button';
        btnClear.innerHTML = '<span style="font-size:1.1em;color:#555;">üóëÔ∏è</span>';
        btnClear.title = 'Remove all';
        btnClear.onclick = (e) => {
          e.stopPropagation();
          currentDeck = currentDeck.filter(c => c.code !== card.code);
          renderDeckMiniatures();
          renderDeckCounters();
        };
        controls.appendChild(btnMinus);
        controls.appendChild(btnPlus);
        controls.appendChild(btnClear);
        wrapper.appendChild(controls);
        deckMiniatures.appendChild(wrapper);
      });
      renderDeckCounters();
      updateSaveButtonState();
    }

    // Also call after loading deck
    function loadDeckFromLocalStorage() {
      const selected = deckSelect.value;
      if (!selected) return;
      const decks = JSON.parse(localStorage.getItem('op_decks') || '{}');
      const deckArr = decks[selected] || [];
      currentDeck = deckArr.map(key => {
        const [code, art_variant] = key.split('|');
        return allCards.find(card => card.code === code && String(card.art_variant) === art_variant);
      }).filter(Boolean);
      deckNameInput.value = selected;
      deckSelect.value = selected;
      renderDeckMiniatures();
      renderDeckCounters();
      showToast('Deck loaded!');
      updateSaveButtonState();
    }

    // Also call after deleting deck
    function deleteSelectedDeck() {
      const selected = deckSelect.value;
      if (!selected) {
        showToast('No deck selected.');
        return;
      }
      if (!confirm(`Delete deck '${selected}'? This cannot be undone.`)) return;
      const decks = JSON.parse(localStorage.getItem('op_decks') || '{}');
      delete decks[selected];
      localStorage.setItem('op_decks', JSON.stringify(decks));
      updateDeckDropdown();
      deckSelect.value = '';
      deckNameInput.value = '';
      currentDeck = [];
      renderDeckMiniatures();
      renderDeckCounters();
      showToast('Deck deleted!');
      updateSaveButtonState();
    }

    // Also call after saving deck
    function saveDeckToLocalStorage() {
      const name = deckNameInput.value.trim();
      if (!name) {
        alert('Please enter a deck name.');
        return;
      }
      if (currentDeck.length !== 51) {
        showToast('Deck must have exactly 51 cards to save.');
        return;
      }
      const decks = JSON.parse(localStorage.getItem('op_decks') || '{}');
      decks[name] = currentDeck.map(card => card.code + '|' + card.art_variant);
      localStorage.setItem('op_decks', JSON.stringify(decks));
      updateDeckDropdown();
      showToast('Deck saved!');
      updateSaveButtonState();
    }

    deckNameInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveDeckToLocalStorage();
      }
    });

    function addCardToDeck(card) {
      // Limit to 4 of each unique card code, or 1 for leader
      const count = currentDeck.filter(c => c.code === card.code).length;
      if (card.category && card.category.toLowerCase() === 'leader') {
        if (count >= 1) {
          return;
        }
        // Only allow one leader in the deck at all
        if (currentDeck.some(c => c.category && c.category.toLowerCase() === 'leader')) {
          return;
        }
      } else if (count >= 4) {
        return;
      }
      if (currentDeck.length >= 51) {
        showToast('Deck is full (51 cards).');
        return;
      }
      currentDeck.push(card);
      renderDeckMiniatures();
      renderDeckCounters();
    }

    function setupCardClickHandlers() {
      document.querySelectorAll('.card').forEach((cardDiv, idx) => {
        // Always recalculate count/maxCount on each event for up-to-date state
        const cardData = filteredCards[idx];
        const isLeader = cardData.category && cardData.category.toLowerCase() === 'leader';
        cardDiv.onmouseenter = cardDiv.onmousemove = function() {
          const count = currentDeck.filter(c => c.code === cardData.code).length;
          const maxCount = isLeader ? 1 : 4;
          // Also gray out if deck is full
          if (count >= maxCount || currentDeck.length >= 51) {
            cardDiv.classList.add('maxed');
            cardDiv.style.cursor = 'not-allowed';
          } else {
            cardDiv.classList.remove('maxed');
            cardDiv.style.cursor = 'pointer';
          }
        };
        cardDiv.onmouseleave = function() {
          cardDiv.classList.remove('maxed');
          cardDiv.style.cursor = 'pointer';
        };
        // Left click: add one if not maxed and deck not full
        cardDiv.onclick = (e) => {
          const count = currentDeck.filter(c => c.code === cardData.code).length;
          const maxCount = isLeader ? 1 : 4;
          if (count >= maxCount || currentDeck.length >= 51) return;
          addCardToDeck(cardData);
        };
        // Right click: add as many as possible up to max, but not over 51, prevent context menu
        cardDiv.oncontextmenu = (e) => {
          e.preventDefault();
          const count = currentDeck.filter(c => c.code === cardData.code).length;
          const maxCount = isLeader ? 1 : 4;
          if (count >= maxCount || currentDeck.length >= 51) return;
          const toAdd = Math.min(maxCount - count, 51 - currentDeck.length);
          for (let i = 0; i < toAdd; i++) {
            addCardToDeck(cardData);
          }
        };
      });
    }

    function updateFilteredCards(){

      const tag_map = {
        atk: "When Attacking",
        don: "DON!! x",
        oatk: "On Your Opponent's Attack",
        opt: "Once Per Turn",
        opl: "On Play",
        rsh: "Rush",
        blk: "Blocker",
        onblk: "On Block",
        main: "Activate: Main",
        trg: "Trigger",
        ctr: "Counter",
        end: "End of Your Turn",
        oko: "On K.O.",
        trn: "Your Turn",
        bsh: "Banish",
        dbl: "Double Attack"
      }

      const searchFilter = document.querySelector(".search input[type='text']").value;
      const colorFilter = Array.from(document.querySelectorAll("input[name='color']")).map(({value, checked})=>checked && value).filter(value =>!!value);
      const categoryFilter = Array.from(document.querySelectorAll("input[name='category']")).map(({value, checked})=>checked && value).filter(value =>!!value);
      const counterFilter = Array.from(document.querySelectorAll("input[name='counter']")).map(({value, checked})=>checked && value).filter(value =>!!value);
      const alternateArtFilter = Array.from(document.querySelectorAll("input[name='hide_alternate_art']")).map(({value, checked})=>checked && value).filter(value =>!!value);
      const sortCriteria = document.querySelector(".sort select").value;
      const tagCriteria = Array.from(document.querySelectorAll("input[name='tag']")).map(({value, checked})=>checked && value).filter(value =>!!value);
      filteredCards = allCards;


      if(searchFilter) {
        // Support comma-separated AND search for multiple terms
        const terms = searchFilter.split(',').map(t => t.trim().toLowerCase()).filter(Boolean);
        filteredCards = filteredCards.filter(({name, type, effect, trigger, code}) => {
          const searchableFields = [name, type, effect, trigger, code].map(f => (f || '').toLowerCase());
          // All terms must be found in any field
          return terms.every(term => searchableFields.some(field => field.includes(term)));
        });
      }
      if(colorFilter.length>0)
        filteredCards = filteredCards.filter(({color}) =>
          colorFilter.includes(color.toLowerCase())
        )
      if(categoryFilter.length>0)
      filteredCards = filteredCards.filter(({category}) =>
        categoryFilter.includes(category.toLowerCase())
      )
      if(counterFilter.length>0)
      filteredCards = filteredCards.filter(({counter}) =>
        counterFilter.includes(counter.toString())
      )
      if(alternateArtFilter.length>0)
      filteredCards = filteredCards.filter(({art_variant})=> art_variant === 0)
      if(tagCriteria.length>0)
      filteredCards = filteredCards.filter(({tags}) => {
          if(!tags)
            return false;
          const tagSet = new Set(tags.split(','));
          return tagCriteria.every(element => tagSet.has(element));
      });
      console.log({filteredCards});

      filteredCards.sort((a, b)=> {
          if(sortCriteria === 'code')
            return a.code.localeCompare(b.code);
          else if(sortCriteria === 'costASC')
            return a.cost - b.cost;
          else if (sortCriteria === 'costDESC')
            return b.cost - a.cost;
      })
      
      displayFilteredCards();
    }

    function imageErrorHandler(element) {
      console.log(element);
      element.onerror = null;
      element.parentNode.children[0].srcset = element.parentNode.children[1].srcset = element.src;
    }

    function displayFilteredCards(){
      cardContainer.innerHTML = "";
      filteredCards.forEach(item => {
          const card = document.createElement('div');
          card.classList.add('card');

          const image = document.createElement('picture');
          image.classList.add('card-image');

          preferredSource = document.createElement('source');
          preferredSource.setAttribute('srcset', item.image);
          backupSource = document.createElement('source');
          backupSource.setAttribute('srcset', item.backup_image);

          fallbackImage = document.createElement('img');
          fallbackImage.src = item.backup_image;
          fallbackImage.loading="lazy";
          fallbackImage.onerror = function() {
            this.onerror = null;
            this.parentNode.children[0].srcset = this.parentNode.children[1].srcset = this.src;
            return true;
          };

          image.appendChild(preferredSource);
          image.appendChild(backupSource);
          image.appendChild(fallbackImage);
          card.appendChild(image);

          cardContainer.appendChild(card);
        });
      setupCardClickHandlers();
    }

    saveDeckBtn.onclick = saveDeckToLocalStorage;
    loadDeckBtn.onclick = loadDeckFromLocalStorage;
    deckSelect.onchange = function() {
      if (deckSelect.value) {
        deckNameInput.value = deckSelect.value;
      }
    };
    document.querySelector('button[name="delete-deck"]').onclick = deleteSelectedDeck;

    fetch('OPTCG.json')
      .then(response => response.json())
      .then(data => {
        console.log({data, test:{...data.cards[0], ...data.card_locales[0]}});
        allCards.push(...data.cards.map(card=> {
          translation = data.card_locales.find((translation) => translation.card_code === card.code && translation.art_variant === card.art_variant);
          return {...card, ...translation, backup_image: card.image}
        }
        ));
        filteredCards = allCards;
        displayFilteredCards();
        updateDeckDropdown();
      })
      .catch(error => {
        console.error('Error fetching data:', error);
        const message = document.createElement('p');
        message.textContent = 'Error loading card data.';
        cardContainer.appendChild(message);
      });
  </script>
</body>
</html>
